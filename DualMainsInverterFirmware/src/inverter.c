#include "inverter.h"
#include "wfg.h"
#include "dmi_adc.h"
#include "tick.h"

#define _INVERTER_BUS_VOLTAGE_FILTER_ALPHA 64 // Fixed point. Maximum 1024

// Amplitude of the baseline output. Channel A and B are referenced to this channel
#define _INVERTER_BASELINE_COEFFICIENT 169706 // amplitude millivolts

// 1000mV * (470k + 470k) / 2k = 470000 mV = full scale voltage on bus when adc reading is 2^12
#define _INVERTER_BUS_FULLSCALE_MILLIVOLTS 470000

volatile int32_t _inverter_bus_voltage_unfiltered = 0; // unfiltered bus voltage measurement from ADC

volatile int32_t _inverter_channel_a_target = 0; // amplitude (peak, not RMS) millivolts
volatile int32_t _inverter_channel_b_target = 0; // amplitude (peak, not RMS) millivolts

static uint16_t _inverter_sinelut[] = {
	0x200,0x20d,0x219,0x226,0x232,0x23f,0x24b,0x258,
	0x264,0x271,0x27d,0x289,0x295,0x2a1,0x2ad,0x2b9,
	0x2c5,0x2d0,0x2dc,0x2e7,0x2f2,0x2fd,0x308,0x313,
	0x31d,0x328,0x332,0x33c,0x346,0x350,0x359,0x362,
	0x36b,0x374,0x37c,0x385,0x38d,0x395,0x39c,0x3a4,
	0x3ab,0x3b2,0x3b8,0x3bf,0x3c5,0x3ca,0x3d0,0x3d5,
	0x3da,0x3df,0x3e3,0x3e7,0x3eb,0x3ee,0x3f1,0x3f4,
	0x3f7,0x3f9,0x3fb,0x3fc,0x3fe,0x3ff,0x400,0x400,
	0x400,0x400,0x3ff,0x3fe,0x3fd,0x3fc,0x3fa,0x3f8,
	0x3f5,0x3f3,0x3f0,0x3ec,0x3e9,0x3e5,0x3e1,0x3dc,
	0x3d8,0x3d2,0x3cd,0x3c7,0x3c2,0x3bb,0x3b5,0x3ae,
	0x3a7,0x3a0,0x399,0x391,0x389,0x381,0x378,0x370,
	0x367,0x35e,0x354,0x34b,0x341,0x337,0x32d,0x323,
	0x318,0x30e,0x303,0x2f8,0x2ed,0x2e1,0x2d6,0x2ca,
	0x2bf,0x2b3,0x2a7,0x29b,0x28f,0x283,0x277,0x26a,
	0x25e,0x252,0x245,0x239,0x22c,0x220,0x213,0x206,
	0x1fa,0x1ed,0x1e0,0x1d4,0x1c7,0x1bb,0x1ae,0x1a2,
	0x196,0x189,0x17d,0x171,0x165,0x159,0x14d,0x141,
	0x136,0x12a,0x11f,0x113,0x108,0x0fd,0x0f2,0x0e8,
	0x0dd,0x0d3,0x0c9,0x0bf,0x0b5,0x0ac,0x0a2,0x099,
	0x090,0x088,0x07f,0x077,0x06f,0x067,0x060,0x059,
	0x052,0x04b,0x045,0x03e,0x039,0x033,0x02e,0x028,
	0x024,0x01f,0x01b,0x017,0x014,0x010,0x00d,0x00b,
	0x008,0x006,0x004,0x003,0x002,0x001,0x000,0x000,
	0x000,0x000,0x001,0x002,0x004,0x005,0x007,0x009,
	0x00c,0x00f,0x012,0x015,0x019,0x01d,0x021,0x026,
	0x02b,0x030,0x036,0x03b,0x041,0x048,0x04e,0x055,
	0x05c,0x064,0x06b,0x073,0x07b,0x084,0x08c,0x095,
	0x09e,0x0a7,0x0b0,0x0ba,0x0c4,0x0ce,0x0d8,0x0e3,
	0x0ed,0x0f8,0x103,0x10e,0x119,0x124,0x130,0x13b,
	0x147,0x153,0x15f,0x16b,0x177,0x183,0x18f,0x19c,
	0x1a8,0x1b5,0x1c1,0x1ce,0x1da,0x1e7,0x1f3,0x200
};

void inverter_init(void) {
	wfg_init();
	dmi_adc_init();
	tick_init(_inverter_callback);
}

void inverter_housekeeping() {
	uint16_t bus_voltage_raw;
	
	dmi_adc_read_conversion(&bus_voltage_raw, ADC_POSITIVE_INPUT_PIN5);
	_inverter_bus_voltage_unfiltered = (((int32_t)bus_voltage_raw) * _INVERTER_BUS_FULLSCALE_MILLIVOLTS) >> 11;
}

void inverter_set_channels(uint32_t channel_a, uint32_t channel_b) {
	system_interrupt_enter_critical_section();
	_inverter_channel_a_target = channel_a;
	_inverter_channel_b_target = channel_b;
	system_interrupt_leave_critical_section();
}

void _inverter_callback(void) {
	static uint16_t i = 0;
	static int32_t bus_voltage = 0;
	static bool baseline_enable = false;
	
	bus_voltage = (_INVERTER_BUS_VOLTAGE_FILTER_ALPHA * _inverter_bus_voltage_unfiltered + (1024 - _INVERTER_BUS_VOLTAGE_FILTER_ALPHA) * bus_voltage) / 1024;
	
	volatile int32_t sineval_raw = (int16_t)_inverter_sinelut[i] - 512;
	volatile int32_t baseline;
	volatile int32_t chan_a, chan_b;
	
	// Hysteresis loop
	if (baseline_enable && bus_voltage - 5000 < _INVERTER_BASELINE_COEFFICIENT) {
		baseline_enable = false;
		port_pin_set_output_level(PIN_PA27, true);
	}
	else if (!baseline_enable && bus_voltage - 12000 > _INVERTER_BASELINE_COEFFICIENT) {
		baseline_enable = true;
		port_pin_set_output_level(PIN_PA27, false);
	}
	
	// Check if bus voltage is high enough to generate baseline signal
	if (baseline_enable) {
		baseline = _INVERTER_BASELINE_COEFFICIENT * sineval_raw / bus_voltage;
		// This needs to be doubled because it refers to peak-to-peak, not amplitude
		chan_a = baseline - 2 * _inverter_channel_a_target * sineval_raw / bus_voltage;
		chan_b = baseline - 2 * _inverter_channel_b_target * sineval_raw / bus_voltage;
	} else {
		// If bus voltage isn't high enough to generate baseline signal, set all outputs to zero.
		baseline = 0;
		chan_a = 0;
		chan_b = 0;
	}
	
	// Up until this point, these values could range from -512 to 512. Shift to unsigned ints
	chan_a = chan_a + 512;
	baseline = baseline + 512;
	chan_b = chan_b + 512;
	
	// Set each channel accordingly
	wfg_channel_set(WFG_CHANNEL_U, (uint16_t)chan_a);
	wfg_channel_set(WFG_CHANNEL_W, (uint16_t)chan_b);
	wfg_channel_set(WFG_CHANNEL_V, (uint16_t)baseline);
	
	// Looping index to cycle through waveform pattern
	i += 1;
	if (i >= (sizeof(_inverter_sinelut) / sizeof(uint16_t)))
		i = 0;
	
	return;
}